# プルリクエストをマージしてもらえない！

イシューが却下されることがあるように、プルリクエストもマージに至らず却下されることがあります。頑張ってプルリクエストしてみてもなかなかマージしてもらえないという場合、もしかしたら頑張り所を間違えているのかもしれません。

変更をマージしてもらえないケースでよくあるのが、コードであったり設計方針だったり運営方針だったりと行ったさまざまなレベルで、*そのプロジェクトに「馴染まない」変更になってしまっている*、というケースです。その場合、そのままの方向で頑張り続けても実を結ばず徒労に終わってしまいます。

なぜ自分の提案内容がプロジェクトに馴染まないのか、どういう所で馴染まないのか。本章では、それらをよく分析して見つめ直してみるための勘所をいくつかご紹介します。


## 既存のコードをよく読もう

### どんなコードが書かれているかを知らないと、馴染むコードは書けない

前述した通り、筆者の考えるプルリクエストの理想は*「元のコードに馴染む、まるで元の開発者が書いたかのように見えるコード」*です。

8章「プルリクエストしてみたい！」では、「技術力に差がありすぎると変更箇所が悪目立ちする」ということを述べました。しかし、技術力があっても変更箇所が悪目立ちすることはあります。筆者の経験上は、*「そもそも馴染ませようという気があるか、ないか」*という所での差異が大きいような印象があります。

他の箇所に馴染むような変更をするためには、「他の箇所」がどういう書かれ方をしているかを把握していないといけません。つまり、*変更対象の既存のコードを、変更箇所以外も含めてもう少し読み込む*必要がある、ということです。

* 変数や関数の名前の付け方の傾向
* モジュールの分割の粒度の傾向
* 全体的な設計方針、設計思想
* コメントに書かれた補足情報

などなど、既存のコードからは色々なことが読み取れます。しかし、本を読むように漫然と先頭から読んでも、内容が頭に入ってこない場合が多いでしょう。それもそのはずです、ソースコードはそのように読むようには書かれていません。*ソースコードを読むには、読み方を知る必要があります*[^how-to-read-existing-codes]。

[^how-to-read-existing-codes]: 既存のコードの読み方について、筆者は以前に業務で、新入社員の方向けの「既存のコードを変更するノウハウ」を学ぶ研修を主導させていただいたことがあります（ https://www.clear-code.com/blog/2018/11/12.html ）。本章の内容の一部は、そのときの講義内容に基づいています。

### コードの語彙力、表現の知識を身に付けよう

文章を読むときには、文法に対する理解だけでなく、単語や慣用句の知識（語彙力）も必要です。

同じことがコードを読むときにも言えます。「こういうことをしたい時に、こういう書き方をする」「こういう効果を狙って、こういう書き方をする」という*「コードの語彙力」*があると、同じコードを読んで得られる情報の量が大きく増えます。コードを読むときの*意識の解像度が上がる*、と言った方がよいかもしれません。

特にポピュラーな表現のパターンを、以下にいくつか挙げてみましょう。

　

*複数の単語からなる識別子の名前付け*には、以下のようなパターンがあり、それぞれよく使われる場面があります。

* *S*omething*N*ame：各単語の先頭1文字を大文字にする。Pascal Case、またはUpper Camel Caseと呼ばれる。クラス名で使われることが多い。
* something*N*ame：2つ目以降の単語の先頭1文字を大文字にする。Camel Case、またはLower Camel Caseと呼ばれる。
* something*_*name：単語同士をアンダースコアで連結する。Snake Caseと呼ばれる。
* something*-*name：単語同士をハイフンで連結する。ケバブケース、チェインケース、ハイフンケースなどと呼ばれる。ファイル名で使われる。
* SOMETHING_NAME：単語をすべて大文字にして連結する。定数でよく使われる。

*複数のデータを保持する変数の名前付け*にも、いくつかのパターンがあります。

* item*s*などの、データの内容を表す単語の複数形。
* item*Array*、item*List*などの、データの内容＋データを保持している構造を表す接尾辞。

個数、件数などの*「数」を保持する変数やプロパティの名前付け*には、以下のようなパターンがあります。

* item_*count*
* item_*length*
* item_*size*
* *n*_items（数学や物理で「N個の」といった言い方をすることにちなむ表現）

*関数名・メソッド名の動詞*にもパターンがあります。たとえば、原形にするか現在形にするかは、何をさせる機能かという目的で変わることが多いです。

* String#split（分割する）などの原形：データに変更を加える、何かをさせるとき。
* String#include*s*（部分文字列を含むかどうか）などの三人称単数形：データの状態を問い合わせ、真偽値で結果を返すとき。

特定の文脈で使われやすい単語や表現にも、いくつかの流儀があります。*状態を問い合わせる場面*では、以下のような例があります。

* *is*Item / *has*Item：Yes/Noで答える疑問文のように名付ける。
* *get*Item*State*：状態を尋ねる、という趣旨をそのまま名前に採用する。
* valid*?*：Rubyのコードでよく見られるパターンで、真偽値を返す場合の接尾辞として「?」を使う。

*データの取得や保存に関わる場面*でも、以下のような例があります。

* *get*Item / *set*Item：値を取得したり変更したりする物について、set-getのペアで名付ける。
* *read*Item / *write*Item：ファイルなど何らかのデバイスやストレージに対してデータを読み書きする場合に、そのことを強調するように名付ける。
* *fetch*Item / *download*Item / *push*Item / *upload*Item ：データをネットワーク越しに取得・保存する場合に、そのことを強調するように名付ける。
* save*!*：Ruby on Rails（のActiveRecord）に見られるパターンで、破壊的な操作をしたり、操作を強行したりする場合の接尾辞として「!」を使う。

　

このほか、言語を問わず「読みやすさ」という観点にフォーカスしてコードの語彙を紹介している本としては、*「リーダブルコード ―より良いコードを書くためのシンプルで実践的なテクニック（Theory in practice）」（オライリージャパンより、2012年刊行）*があります。この本を読んでからOSSのコードに触れると、「あっ、この書き方は読みやすさのための工夫をしている！」という箇所に気付きやすくなり、プロジェクト内でどのような流儀を採用しているかをより読み取りやすくなるでしょう。

また、変数や関数の名前付けといったミクロな部分だけでなく、モジュールの設計というマクロな部分にも、いろいろな流儀があります。設計の流儀でよく知られているのは、*「デザインパターン」*です。皆さんも「シングルトン」とか「オブザーバー」とか「イテレーター」とかいった言葉を聞いたことはないでしょうか？

デザインパターンは、複雑な問題に対処するときの典型的な設計パターンとしてよく使われています。本書では掘り下げませんが、例を交えての解説もすでに世の中に多数存在するので、概要だけでも頭に入れておくことをおすすめします。そうすると、コードを読むときに「あ、これは○○パターンだ！」と知識を当てはめられるので、*見通しがよくなり、理解が進みやすくなります*。

### 手がかりになる所から読もう

既存のコードを頭からすべて読み下すというのは、規模の大きなソフトウェアでは非現実的です。筆者は、*ユーザーとして自分がよく使う機能など、特定の動作に対応するコードから読む*のをおすすめします。具体的には、たとえば以下のようなやり方があります。

* 警告メッセージなど、*画面に表示されるメッセージ文字列の定義*からたどる方法。「このメッセージを表示している処理はどこか」ということを、ソースコード中を検索して特定する。
* 「HKEY_CURRENT_USER」など、*設定のキー名やレジストリのキーに使われる文字列*からたどる方法。「この文字列が埋め込まれている場所はどこか」ということを、ソースコード内を検索して特定する。
* *機能の名前*からたどる方法。「この機能を実装しているモジュールや関数の定義場所はどこか」ということを、ソースコード内を検索して特定する。
* *既知のAPI*からたどる方法。たとえばWindows用アプリケーションであれば、.NET Frameworkの「RegistryValueKind.QWord」という定数名でソースコード中を検索すると、Windowsレジストリを読み書きしている箇所を特定できる。
  * その言語やAPIを知らなくても、「Windows レジストリ 読み書き」のようなキーワードで*「その分野でそういうアプリケーションを作りたい人向けの情報」*を探すと、調べるべきキーワードにたどり着けることがある。

知っている挙動に確実に対応している箇所をソースコード中から特定できれば、あとはその処理の呼び出し元をたどっていくことで、「なるほど、この動作を実現しているのはこんなコードなんだ」と、*「既知の挙動の前後の挙動」と「呼び出し元の前後のコード」とを対応付けて読む*ことができます。

ソースコードを編集して独自改変版を動かせる状況であれば、その箇所で例外を意図的に発生させるように改変してみてもいいでしょう。例外発生時のスタックトレース（バックトレース）を見て、処理の呼び出し元を一気に把握することもできます。

また、コードを読む手がかりとなる資料としては、*自動テスト*も有用です。自動テストでは多くの場合、テスト対象のモジュールをその場で初期化して各機能を呼び出して使うため、実際の動作時にどんな引数を伴ってどんな呼び出し方がなされるのかを把握する上で、大変参考になります。

## コード以外の部分も「馴染む」プルリクエストにしよう

### コミットログの書き方も揃えよう

コードの変更そのものとは無関係ですが、*コミットログの書き方の様式*も、そのプロジェクトの流儀に合わせるようにしましょう。プロジェクトによってはコミットログをリリースノート作成時の参考資料にすることがあり、あまりに様式から外れていると、リリース時に開発者に余計な苦労を強いることになってしまいます。

コミットログは基本的には、5W1H[^5w1h]のうちの「Why」にフォーカスをあてて書きます。たとえば以下のような要領です。

[^5w1h]: 「Who（誰が）」「When（いつ）」「Where（どこで）」「What（何を）」「Why（なぜ）」「How（どのように）」という、ニュース記事を書くときに盛り込むべき情報の一覧を端的に示したもの。

* 「ユーザーがグループに所属していない時にログインに失敗する問題を修正」
* 「チケットの作成時に空のフィールドを許容しないように変更」

プロジェクトによっては、リポジトリに含まれるドキュメントの修正のコミットメッセージ冒頭には「`doc:`」、自動テストの修正のコミットには「`test:`」、といった印（プレフィクス）を付けるよう運用で定めている場合もあります。開発への参加の仕方についての説明があればそれを参照して、運用ルール自体を把握するのと同時に、他の変更がどんなコミットメッセージでなされているか、実際のコミットログも併せて確認するとよいでしょう。

### 次に作業する人のことを意識しよう

変更箇所のコードを既存のコードに馴染ませたり、コミットログを合わせたりするのは、*その変更を受け入れた後も、開発者が違和感なくその箇所に手を入れ続けられるようにする*ためです。

コードの書き方に見られる様々な流儀の例を先に紹介しましたが、OSSでのプルリクエストにおいては、「どの流儀が優れているか」ということ自体はあまり重要ではありません。それよりも、そのOSSではどの流儀に従っているのかを把握して、流儀を合わせることが大事です。なぜなら、*プロジェクトの中で流儀が統一されているかどうかの方が、コードの読みやすさや開発の効率に与える影響は大きい*からです。

あなたはプルリクエストをした後は、それ以後もうそのコードのことを読み返さないかもしれません。しかし、*受け入れた側のプロジェクトオーナーは、その後もずっとそのコードをメンテナンスし続ける*ことになります。効率よく作業するためには、何かあったとき、プロジェクト内の一般的な傾向に従って探せば問題箇所をすぐ見つけられる、という状態を維持することが大切です。名前の付け方も、設計の仕方も、よく「馴染んだ」コードにするのはそのためなのです。


## 他の事例紹介からも学ぼう

本書は特定のOSSプロジェクトに特化せず一般的な解説をするようにしていますが、小規模な個人開発のOSSではよくても、多人数が関わる大きなOSSとなると、そのプロジェクト固有の事情というものが増えてきます。一般的には問題無くともそのプロジェクトでは禁止事項になっている、という事柄がある場合もあります。

タイミングがいいことに、本書の執筆時期に前後して、大規模なOSSプロジェクトに深く関わっている人の手による、*「初めてのフィードバック」や「フィードバックでつまずきやすい点」に焦点を当てた良質な記事・資料*が複数公開されていました。本書と併せて読んでいただけるよう、いくつかご紹介します。

[Node.jsへのコントリビュート解説、そしてOSSへ貢献するということ](https://shisama.hatenablog.com/entry/2019/12/04/204400)

Node.js Core Collaboratorで関西Node学園主宰のMasashi Hirano（shisama）氏による、Node.js Advent Calendar 2019内の記事です。本書ではあまり詳しく述べていない、*プルリクエストの具体的な手順やベストプラクティス*に多くの分量が割かれていて、本書だけではまだピンと来ないという方が参照するのにうってつけの内容です。

[OSSで結果を出す方法](https://speakerdeck.com/knu/ossdejie-guo-wochu-sufang-fa)

Rubyコミッターの武者晶紀（knu）氏による、平成Ruby会議01での発表の資料です。プロジェクト運営側として活動されていることから、*「こういうプルリクエストは送られても困る」という事例*がその理由も含めて多数紹介されています。プロジェクトオーナーの視点に馴染みが薄い人にとっては、「向こうから見ると、そういう見え方になるのか」という学びを多く得られるでしょう。

[OSS初心者がつまづきながらOSSマナーを学んでいく話](https://twitter.com/fuqda90/status/1147367427526627329)

Tama.rb主宰のfuqda氏による、Tama Ruby会議01での発表です。*プロジェクトの方針に合わないプルリクエストをしてしまい、識者のアドバイスを受けて方針に合うように修正してマージにこぎ着けた*、という事例が紹介されています。自分1人では詰まってしまうような場面で、学校や会社の先輩などの近い距離に頼れる人がいない場合でも、コミュニティに関わると先達の手助けを得られる、ということがよく分かります。


## 何をしても駄目なときは

### フォークするしかない？　無闇にフォークしちゃ駄目？

プロジェクトのスコープに収まる問題として提案し、自分の目で「プロジェクトによく馴染んでいる」と思えるレベルにまで練り上げたプルリクエストも用意したとしても、要望・提案を受け入れてもらえない場合はあります。最終的に要望を受け入れるかどうかは、そのプロジェクト内部の人が決定することです。外部から協力するだけの立場の人には、残念ですがその判断への介入はできません。

そういうときに、外部協力者の立場で取れる最後の手段が、*プロジェクトのフォーク*です。設定されているライセンスの条件に従う限り、誰もが自由にそのOSSを改造し、再配布することができます。プルリクエストのために一時的にフォークするのではなく、改造の成果を元の開発プロジェクトに還元しないまま独立したプロジェクトとして継続する、という選択肢です。

リソースの無駄な分散を防ぐためにも、ユーザーの混乱を避けるためにも、*フォークは可能な限り避けるのが望ましい*です。どうしてもフォークする場合は、それ以後の開発やメンテナンスに要するすべてのリソースを自前でまかない、最後までそのソフトウェアの面倒を見続ける覚悟が必要です。

そのため、大きなOSSプロジェクトほど、フォークは珍しいです。近年で観測された大きなフォークといえば、WebKitからGoogleがフォークして始めたBlinkのように、*フォーク主体に膨大なリソースがある場合*か、OpenOffice.orgからのLibreOfficeやownCloudからのNextcloudのように、*フォーク元の主要開発者達が何らかの理由で元プロジェクトから離反して、フォーク先にそのまま合流した場合*くらいでしょう。

Firefox 28からフォークしたPale Moonや、Firefox 56からフォークしたWaterfoxのように、個人や少人数のグループが大規模なプロジェクトをフォークしたケースは、*健全な状態を保ち続けられていないことが多い*、という印象が筆者にはあります[^forked-gecko]。「フォークしたはいいものの、実際やってみたらメンテナンスが意外と大変で、しばらくしたら更新が滞ってしまいました」というのは、ユーザーに過剰な期待を持たせた挙げ句に振り回してしまう、最悪の結末です。

[^forked-gecko]: これらのフォーク版は、フォーク以後のFirefoxで行われた性能向上や安全性向上のための抜本的な変更、最新のWeb技術への対応などが反映されておらず、最新のFirefoxと比べるとだいぶ見劣りする状態になっています。

### いざというときの選択肢として

しかし、そうは言っても「絶対にフォークしてはならない」というわけでもありません。

上述のとおり、プロジェクトの運営主体を完全に引き継いで責任を持って継続できそうなのであれば、あるいは、フォーク版を自分しか使わなくて不利益はすべて折り込み済みなのであれば、フォークは選択肢の一つとして考慮する価値があります。

実際に筆者にも、元プロジェクトには絶対に取り込んでもらえない独自の機能が、どうしても切実に業務上必要だという理由で、[他の人の開発したOSSをフォークして以後、ニーズに応じて回収を続けながら10年近く維持し続けている実例](https://github.com/clear-code/flex-confirm-mail/)があります。

*「いざとなったらフォークして続けられる」*という点は、OSSの強みです。もしフォークという手段が許されていなければ、やりたいビジネスを諦めたり、自分の使い方での致命的な不便を強いられたりしなくてはなりません。*覚悟と努力次第で困難を乗り越えられる余地が常に残されている*ということに筆者は安心感を覚え、逆に、プロプライエタリな製品には「これ、いつまで使い続けられるんだろう？」と不安を覚える、というのは、誇張ではなく実際の思いです。

　

「そんなタフな選択ができるのは、あなた（筆者）がスーパーエンジニアだからだ」と思われるでしょうか？

いいえ、そんなことはありません。筆者のOSS開発者としてのキャリア自体、*他の人が開発を放棄して動かなくなってしまったソフトウェアを、再び動くように見よう見まねで修正した*ところから始まっています[^fork-of-non-free-software]。当時の筆者はオブジェクト指向もロクに分かっていないようなド素人でした。その元ソフトウェアはごく単純な物でしたが、それでも当時の筆者にとっては、全貌を理解しきれない、手に余る代物としか思えませんでした。

[^fork-of-non-free-software]: 実を言うと、このときフォークの元にしたソフトウェア（Mozilla Application Suiteのコンテキストメニュー拡張機能）にはオープンソースライセンスが設定されていませんでした。自分の記憶が正しければ、元の作者の方が「習作のような物なので権利は主張しない」という旨のことをおっしゃっていたため、パブリックドメイン扱いとして、こちらでオープンソースなライセンスを設定したという経緯だったように思います。

しかし、動かなくなっていた原因箇所をどうにか直して動く状態に戻せたことで、筆者は*それを足がかりとして学習を進められました*。当時の筆者にとっては、入門書に書かれていた内容（基本中の基本）と自分のやりたかった事（高度なGUIを持つソフトウェア）との間のギャップが大きすぎて途方に暮れていましたが、「すでに動く状態のソフトウェア」のソースコードを読むことによって、*「やりたい事を実現できた」という喜びや、「そうか、こういう機能を作りたいときはこういう書き方をするんだ」という実践的な知識*を得ていけたのでした。

また、ソフトウェアの公開の仕方、継続的なメンテナンスの仕方、要望の受け答えの仕方など、*コーディングそのものとは異なる周辺領域の様々な経験*についても、そうして「自分のプロジェクト」を持つようになって以降、必要に迫られて身に着ける形で、非常に多くのものを得られました。

本書は「OSSへのフィードバックの仕方」を解説していますが、実際の所、*良いフィードバックとは「プロジェクトオーナーが受け取って嬉しいと思えるフィードバック」の一言に尽きます*。どうだったら嬉しいのかということは、プロジェクトオーナーの立場を経験してみるとよく分かる部分が多々あります。そういう機会になるという意味で、皆さんもフォークをきっかけに「自分のプロジェクト」を持ってみてはいかがでしょうか？
